<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: puppet | Stefano Zanella's Blog]]></title>
  <link href="http://blog.dontwakethecat.net/blog/categories/puppet/atom.xml" rel="self"/>
  <link href="http://blog.dontwakethecat.net/"/>
  <updated>2013-02-13T23:26:13+01:00</updated>
  <id>http://blog.dontwakethecat.net/</id>
  <author>
    <name><![CDATA[Stefano Zanella]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Master of Puppets (vol. II)]]></title>
    <link href="http://blog.dontwakethecat.net/blog/2013/01/22/master-of-puppets-vol-ii/"/>
    <updated>2013-01-22T15:14:00+01:00</updated>
    <id>http://blog.dontwakethecat.net/blog/2013/01/22/master-of-puppets-vol-ii</id>
    <content type="html"><![CDATA[<p>I'll continue here what I'll started in the
<a href="http://blog.dontwakethecat.net/blog/2013/01/20/master-of-puppets/">previous post</a>.
We now have a working Puppet Master installation; still, if we want to update
the configuration of the master itself or of one of the managed nodes, we need
to log into the virtual machine and manually edit the files in <code>/etc/puppet</code>.<br/>
What we want to achieve in the long term, though, is to not need to SSH into
machines for this kind of normal operations tasks.</p>

<!-- More -->


<p>So we need a way to extract the configuration contained in the <code>/etc/puppet</code>
directory so that we can manage it from our laptop with our favorite editor.
While we're at this, we also put that configuration under version control,
which is always a good thing to do.<br/>
The two friends that will help us in this little journey are
<a href="http://jenkins-ci.org/">Jenkins</a> and the
<a href="http://code.google.com/p/gerrit/">Gerrit Code Review</a> application.</p>

<p>Plugins needed:
<a href="https://wiki.jenkins-ci.org/display/JENKINS/SSH+plugin">SSH Plugin</a>
NO --> <a href="https://wiki.jenkins-ci.org/display/JENKINS/Publish+Over+SSH+Plugin">Publish over SSH</a>
NO --> <a href="https://wiki.jenkins-ci.org/display/JENKINS/SSH+Agent+Plugin">SSH Agent Plugin</a></p>

<p><code>
yum install git
usermod -s /bin/bash puppet
mkdir ~puppet/.ssh
vi ~puppet/.ssh/authorized_keys
...show options
chown puppet:puppet -R ~puppet/.ssh/
chmod og-rw -R ~puppet/.ssh/
</code></p>

<p>Configure job in Jenkins
--> Setup git URL</p>

<p>Configure Gerrit trigger</p>

<p>Configure Gerrit to handle non-interactive user
* Perform initial connection with Jenkins user
* Add SSH public key
* Login as Administrator
* Groups -> List -> Non-interactive users
* Add user Jenkins to group</p>

<p>Configure access rights for non-interactive users
* Login as administrator
* Projects -> All-Projects -> Access
* Reference: refs/* -> Label Verified +1, -1 Non-interactive users; Submit
  ALLOW Registerd Users
Configure plugin in Jenkins</p>

<p>Setup connection params
Setup default submit when +2 --> add '--submit' to Successfull verify command
<Add screenshot></p>

<p>Setup global username and email for Git Plugin in Manage Jenkins</p>

<p>Create Gerrit project
ssh -p 29418 stefano.zanella@review.derecom.it gerrit create-project --name puppetmaster-config
git clone ssh://stefano.zanella@review.derecom.it:29418/puppetmaster-config.git
cd puppetmaster-config
git config remote.origin.push refs/heads/<em>:refs/for/</em>
scp -P 29418 stefano.zanella@review.derecom.it:hooks/commit-msg .git/hooks</p>

<p>Add puppet configuration
scp -r root@puppet.derecom.it:/etc/puppet/* .
touch manifests/.gitkeep
touch modules/.gitkeep
git add -A
git commit -m "Store current configuration"
git push</p>

<p>Create Jenkins job for reviewing configuration changes
puppetmaster-config-review
Source Code Management: Git
Repositories: ssh://jenkins@review.derecom.it:29418/puppetmaster-config
Click on Advanced
Refspec $GERRIT_REFSPEC
Branches to build $GERRIT_BRANCH
Click on Advanced
Choosing Strategy = Gerrit Trigger
Build Triggers
Select Gerrit event
Click Advanced
Verify votes:
0, 1, -1, 0
0, 2, -2, 0
Trigger on Patchset Created
Gerrit project: Type Plain, Pattern puppetmaster-config, Branches: Type Path
Branches **
Build -> Add build step -> Execute Shell
Command:
echo "Nothing to check, build OK"
exit 0</p>

<p>Add Gerrit host to known hosts on the slave. Also add Jenkins public/private
key to slave .ssh, otherwise it won't be able to connect to Gerrit.</p>

<p>Add Jenkins job to update configuration on Puppet Master
puppetmaster-config-deploy
Source Code Management: None
Build Triggers: Gerrit Event
Gerrit Trigger:
Silent Mode on
Trigger on: Change merged
Gerrit project: as above
Build: execute shell script on remote host using ssh
SSH Site: puppet@puppet.derecom.it:22
Command: cd /etc/puppet &amp;&amp; git pull</p>

<p>Note that this kind of trigger mode cannot be tested in Jenkins with the
Gerrit tool in the dashboard's homepage. You must actually push a change and
test the whole workflow.</p>

<p>Swap configuration directory with repository
cp -r /etc/puppet /etc/puppet.bak
git clone https://review.derecom.it/puppetmaster-config /etc/puppet</p>

<p>Add Jenkins job to update configuration on Puppet Master
puppetmaster-config-deploy
Source Code Management: None
Build Triggers: Gerrit Event
Gerrit Trigger:
Silent Mode on
Trigger on: Change merged
Gerrit project: as above
Build: execute shell script on remote host using ssh
SSH Site: puppet@puppet.derecom.it:22
Command: source .bash_profile &amp;&amp; cd /etc/puppet &amp;&amp; git pull &amp;&amp; rake</p>

<p>Rake default task: DESCRIPTION!!!</p>

<p>Note that this kind of trigger mode cannot be tested in Jenkins with the
Gerrit tool in the dashboard's homepage. You must actually push a change and
test the whole workflow.</p>

<p>Add CA to ca-bundle
cat /etc/pki/tls/certs/Derecom-Auth-CA-bundle.crt | ssh root@puppet.derecom.it "cat >> /etc/pki/tls/certs/ca-bundle.crt"</p>

<p>Install rbenv on puppet master
yum groupinstall 'development tools'
yum install zlib-devel libxml2-devel libxslt-devel openssl-devel
su - puppet -s /bin/bash
git clone git://github.com/sstephenson/rbenv.git ~/.rbenv
git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bash_profile
echo 'eval "$(rbenv init -)"' >> ~/.bash_profile</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Master of Puppets]]></title>
    <link href="http://blog.dontwakethecat.net/blog/2013/01/20/master-of-puppets/"/>
    <updated>2013-01-20T01:16:00+01:00</updated>
    <id>http://blog.dontwakethecat.net/blog/2013/01/20/master-of-puppets</id>
    <content type="html"><![CDATA[<p>Let me start the real first post of this blog (apart from the introduction)
with a citation. Despite the title, I won't talk about music. Instead, I'll
show you a photo:</p>

<!-- More -->


<p><img src="http://farm9.staticflickr.com/8330/8395925627_7fd19c4aba_z.jpg"></p>

<p>It's a shot I've taken in <strong>Bern</strong> on August 2011; it's the window of a toys
shop you can find under the cloisters of Gerechtigkeitstra√üe. Its name? <em>Antics
und Puppenklinik</em>, which even without translation projects us directly to the
focus of this and probably subsequent writings.</p>

<p>As promised in my <a href="http://blog.dontwakethecat.net/blog/2013/01/19/pre-flight-debrief/">first post</a>
I'll document the setup of a node that will act as the <strong>puppetmaster</strong> for my
company's network. If you don't know what I'm talking about, you probably
landed on the wrong page.<br/>
If, however, you're a sysadmin or an operations guy
and still don't know what I'm talking about, you should <strong>IMMEDIATELY</strong> go
checking out <a href="http://docs.puppetlabs.com/">Puppet Documentation</a> on the
<a href="http://puppetlabs.com/">Puppet Labs website</a>.</p>

<p>Before starting, here's a brief overview. We'll start by installing a fresh
<strong>CentOS 6.3</strong> on a <strong>KVM</strong> virtual machine, then we will step into installing
<strong>Puppet</strong> and configuring it so it can start talking with other machines. For
sure, it isn't rocket science; but again, I'm just trying to document the most
I can about what I do.</p>

<h2>Installing Bare OS</h2>

<p>Select OS for the task is, as preannounced, <strong>CentOS</strong>. This is my standard
choice where no special features are needed (think multimedia packages, for the
most part). The reason of this choice is not fully clear even to me, but I
think my preference goes to it for its small footprint, the availability of
third-party repositories with fairly updated, yet robust, packages that makes
it in general quite stable, even when upgrading. On this subject, I remember
painful hours spent on distro/packages broken upgrade paths with Debian and
derivatives; I'm sure things got better in the last few years, but for the
moment I see little to no reason to move to another OS as my standard choice.</p>

<p>The puppetmaster will run on a VM hosted on a KVM hypervisor; I can hear you
say: <em>"Why not cloud?"</em>. I can say there's a reason, which is associated
mainly to costs, but I'll leave that discussion for another post.</p>

<p>To install VMs on KVM/libvirt I usually rely on <strong>virt-install</strong>, a Python tool
that takes care of generating the relevant XML definition for the VM and booting
it with an installation media that it's removed when installation finishes.<br/>
On CentOS, it can be installed on the hypervisor simply with:
<code>bash
yum install python-virtinst
</code></p>

<p>I won't go through here on what you need to have a working KVM setup: the only
thing I need to point out for the moment is that I have configured a pool in
libvirt associated to a <strong>LVM Volume Group</strong> called <code>vmstorage</code>.</p>

<p>That said, let's start the installation process. We'll create a VM with <strong>1GB
RAM</strong>, <strong>1 virtual CPU</strong> and <strong>10GB of storage</strong>. You can download the CentOS
installation CD .iso from
<a href="http://mi.mirror.garr.it/mirrors/CentOS/6.3/isos/x86_64/CentOS-6.3-x86_64-minimal.iso">here</a>.
I suggest downloading the minimal installation pack since it requires much less
space than the full DVD and provides everything needed to install a bare
minimum system.
Once you have saved the installation media, say, into <code>/media</code>, we can proceed
with booting the VM:
<code>bash
virt-install --name=bernstein --ram=1024 --vcpus=1 \
--cdrom=/media/CentOS-6.3-x86_64-minimal.iso \
--os-type=linux --os-variant=rhel6 \
--disk pool=vmstorage,size=10 --network bridge=br0,model=e1000 \
--video=vga --vnc --connect qemu:///system
</code>
At this point we don't have any textual access to the VM; however, we can
setup a SSH tunnel to the hypervisor binding the port where the VNC server
for the instance is listening, which can be found with:
<code>bash
virsh vncdisplay bernstein
:3
</code>
After that, if you are working on a Mac, i suggest you to try the excellent
<a href="http://sourceforge.net/projects/chicken/">Chicken</a> VNC client (I've
tried many, even the Screen Sharing app available by default, but found this is
the app that works best). The latest version (<strong>2.2b2</strong> as time of writing)
can also automatically setup a SSH tunnel for you.</p>

<p>After we have a connection to the VM's display, we can start the installation
process. To fully document it, I'd need to share a screenshot for every step.
Since I'm not a Martian, you will excuse me if I go through this phase by
simply pointing out the relevant configuration options.
Here are the values of the fields filled during installation:</p>

<ul>
<li><strong>Language</strong>: English</li>
<li><strong>Keyboard layout</strong>: U.S. English</li>
<li><strong>Device Type</strong>: Basic Storage Devices</li>
<li><strong>Hostname</strong>: bernstein.derecom.it</li>
<li><strong>Timezone</strong>: Europe/Rome</li>
<li><strong>Root password</strong>: Hahaha, really you thought I'd have told you?</li>
<li><strong>Disk partitioning</strong>: Select <em>"Replace Existing Linux Systems"</em>, then tick
<em>Review and modify partitioning layout</em>. Modify default layout as follows:

<ul>
<li>/dev/vda1   500   ext4    /boot</li>
<li>/dev/vda2   9739  LVM     os

<ul>
<li>root      7720  ext4    /root</li>
<li>swap      2016  swap    -</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>After the installation process finishes, the VM will be shut down. If we want
to restart it and also have it automatically restarted when server reboots, we
can issue the following commands:
<code>bash
virsh autostart bernstein
virsh start bernstein
</code>
After that, we still need to connect via VNC before we'll be able to SSH into
the machine. Here are the basic steps needed to setup networking (I do not use
DHCP on the main server's subnet):
<code>bash
vi /etc/sysconfig/network-scripts/ifcfg-eth0
</code>
<code>
DEVICE="eth0"
BOOTPROTO="static"
HWADDR="52:54:00:77:21:AE"
NM_CONTROLLED="no"
ONBOOT="yes"
TYPE="Ethernet"
UUID="8af5d6eb-e0c3-4401-9fd9-cad42c011d3b"
IPADDR=172.16.32.253
NETMASK=255.255.255.0
GATEWAY=172.16.32.254
DNS1=8.8.8.8
</code>
<code>bash
service network restart
</code>
Also, I setup some mnemonic entries on our authoritative DNS. They will come in
handy very soon:
<code>
bernstein               A       172.16.32.253
puppet                  CNAME   bernstein
puppetmaster            CNAME   bernstein
</code></p>

<p>At this point, we can start do some basic configuration before installing
Puppet.</p>

<h2>Basic Configuration</h2>

<p>First thing first: disable SELinux. I haven't found the time yet to study and
understand how SELinux works, so I still prefer to let it out of the game:
<code>bash
sed -i -e 's/SELINUX=enforcing/SELINUX=permissive/g' /etc/sysconfig/selinux
setenforce permissive # This way we avoid to reboot
</code></p>

<p>Then, I usually install two additional repositories before doing anything else:
<a href="http://fedoraproject.org/wiki/EPEL">EPEL</a> and
<a href="http://repoforge.org/">RepoForge (was RPMForge)</a>:
<code>bash
rpm -Uvh http://ftp.upjs.sk/pub/mirrors/epel/6/x86_64/epel-release-6-8.noarch.rpm
rpm -Uvh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.2-2.el6.rf.x86_64.rpm
</code>
Then it's good to update available software:
<code>bash
yum update
</code>
The next step regards NTP and shouldn't be needed, but in my case I found it necessary.<br/>
In fact, in virtualized environments clock sync should be provided directly by
hypervisor by exposing an already NTP synced RTC. This was actually the case
when I used to use Xen, and it still works like that in KVM; the only problem
is that the clock still presents jiffies. So, the best thing to do is install
NTP and forget about that:
<code>bash
yum install ntp
chkconfig ntpd on
</code>
Before starting the service, we force an initial synchronization with:
<code>bash
ntpd -q
</code>
Then:
<code>bash
service ntpd start
</code>
Till now, I never encountered problems with the provided defaults. Maybe in the future
I'll also dig into this aspect and customize the configuration; for the moment
I'll leave as it is.</p>

<p>This ends the list of basic configuration tasks I usually do. We can now
stop to shave the yak and proceed to dig into the actual subject of the post.</p>

<h2>Installing Puppet</h2>

<p>The awesome guys at <a href="http://puppetlabs.com">Puppet Labs</a> provide the right
repositories for the job; we can just add them and perform a one-command Puppet
installation:
<code>bash
rpm -Uvh http://yum.puppetlabs.com/el/6/products/x86_64/puppetlabs-release-6-6.noarch.rpm
</code>
If you want to dig more into the topic, here's a
<a href="http://docs.puppetlabs.com/guides/puppetlabs_package_repositories.html">very good section</a>
on the Puppet Labs documentation site.</p>

<p>After adding the repo, Puppet server can be installed with:
<code>bash
yum install puppet-server
</code>
This will also take care of installing Ruby. The latest version available in
CentOS is still a 1.8.7 as time of writing, but it's perfectly suitable to run
Puppet's applications.</p>

<h2>Configuring the Master</h2>

<p>We want to configure the puppetmaster both as the master as well as an agent
for itself. Both configurations are done in <code>/etc/puppet/puppet.conf</code>.<br/>
We start by configuring the most basic options for both the master and the
agent; then we'll move into configuring the right SSL support for our
infrastructure.</p>

<h3>Basic configuration options</h3>

<p>For what concerns the master, the only option we touch for the moment is the
one that enables distribution of custom facts and types from the server to the
agents (plugin sync):
<code>ini
[main]
...
pluginsync = true
...
</code>
This same option, since it is set in the <code>main</code> section, also apply for the
agent.</p>

<p>Also, for the agent, we set the appropriate name for the master via the
<code>server</code> directive. By default the agent would look for an host named <code>puppet</code>;
since our master will be reachable via its FQDN, we need to be explicit about
this. This option belongs to the <code>agent</code> section:
<code>ini
[agent]
...
server = puppet.derecom.it
...
</code></p>

<h3>SSL Setup</h3>

<p><em>I lost almost an afternoon writing about my intended SSL setup, just to
discover that as of current version (3.0.2), Puppet pose serious limits on
swapping its internal PKI management. In my head, I wanted to completely
disable it and provide certificates myself from my already working PKI.<br/>
Unfortunately, there's a serious incompatibility in how OpenSSL creates
certificates subjects and what Puppet intends as a "valid" subject. If you
want, you can read more <a href="http://projects.puppetlabs.com/issues/15561">here</a>.<br/>
Until the issue is resolved, I'm forced to rely on default PKI management; for
this to work, no additional configuration steps are needed.</em></p>

<h3>Service Setup</h3>

<p>Now we're finally ready to start the master. With everything in place, it's no harder than:
<code>bash
service puppetmaster start
</code></p>

<p>Similarly, for the agent:
<code>bash
chkconfig puppet on
service puppet start
</code></p>

<p>Notice that we don't enable the provided service for the master at boot. This is
because we'll setup a proxy with Nginx and Passenger as the following task. We
just run it once so the master can create its own PKI, which is needed in order
to accomplish the following section.</p>

<h3>Proxying Master with Nginx + Passenger</h3>

<p>As suggested by
<a href="http://docs.puppetlabs.com/guides/installation.html#post-install">official documentation</a>,
the default WEBrick server is not suitable for real-life workloads. So, here
we'll setup the master to receive requests from a proxy instead of directly
handling them. Selected stack is <a href="http://httpd.apache.org/">Apache</a> and
<a href="http://www.modrails.com/">Phusion Passenger</a>. This is because the version of
nginx that can be found into Passenger or EPEL repos doesn't ship with the
<code>ngx_headers_more</code> module, needed to set additional headers when processing
client requests.
The procedure depicted here is adapted from the relative
<a href="http://docs.puppetlabs.com/guides/passenger.html">article</a> in Puppet's
documentation.</p>

<p>We start by adding the Phusion Passenger repository, which provides an updated
version of Passenger itself, as well as some other goodies we don't need ATM:
<code>bash
yum install http://passenger.stealthymonkeys.com/rhel/6/passenger-release.noarch.rpm
</code></p>

<p>Then we install the relevant applications:
<code>bash
yum install httpd mod_passenger mod_ssl
</code></p>

<p>At this point we need to setup a root for the Rack application that will serve
Puppet requests. A default Rack application expects three files:</p>

<ul>
<li>a <code>config.ru</code> which can be called by Rack itself</li>
<li>a <code>public/</code> folder</li>
<li>a <code>tmp/</code> folder</li>
</ul>


<p>We start with the required folders, setting our root at <code>/opt/puppetmaster</code>:
<code>bash
mkdir -p /opt/puppetmaster/{tmp,public}
</code></p>

<p>Thankfully, Puppet Labs ships a working <code>config.ru</code> file into the master's
package:
<code>bash
cp /usr/share/puppet/ext/rack/files/config.ru /opt/puppetmaster/
chown puppet:puppet /opt/puppetmaster/config.ru
</code></p>

<p>The only thins that's left to do is to setup the required Apache virtual host.
Again, Puppet Labs provides a sample configuration file that can be used as a
base:
<code>bash
cp /usr/share/puppet/ext/rack/files/apache2.conf /etc/httpd/conf.d/puppetmaster.conf
</code></p>

<p>The content of the file must be edited to reflect actual paths as follows:
```</p>

<h1>Tunable settings</h1>

<p>PassengerHighPerformance on
PassengerMaxPoolSize 12
PassengerPoolIdleTime 1500</p>

<h1>PassengerMaxRequests 1000</h1>

<p>PassengerStatThrottleRate 120
RackAutoDetect Off
RailsAutoDetect Off</p>

<p>Listen 8140</p>

<p><VirtualHost *:8140></p>

<pre><code>    SSLEngine on
    SSLProtocol -ALL +SSLv3 +TLSv1
    SSLCipherSuite ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:-LOW:-SSLv2:-EXP

    SSLCertificateFile
</code></pre>

<p>/var/lib/puppet/ssl/certs/bernstein.derecom.it.pem</p>

<pre><code>    SSLCertificateKeyFile
</code></pre>

<p>/var/lib/puppet/ssl/private_keys/bernstein.derecom.it.pem</p>

<pre><code>    SSLCertificateChainFile /var/lib/puppet/ssl/certs/ca.pem
    SSLCACertificateFile    /var/lib/puppet/ssl/certs/ca.pem
    SSLCARevocationFile     /var/lib/puppet/ssl/crl.pem
    SSLVerifyClient optional
    SSLVerifyDepth  1
    # The `ExportCertData` option is needed for agent certificate
</code></pre>

<p>expiration warnings</p>

<pre><code>    SSLOptions +StdEnvVars +ExportCertData

    # This header needs to be set if using a loadbalancer or proxy
    RequestHeader unset X-Forwarded-For

    RequestHeader set X-SSL-Subject %{SSL_CLIENT_S_DN}e
    RequestHeader set X-Client-DN %{SSL_CLIENT_S_DN}e
    RequestHeader set X-Client-Verify %{SSL_CLIENT_VERIFY}e

    DocumentRoot /opt/puppetmaster/public/
    RackBaseURI /
    &lt;Directory /opt/puppetmaster/&gt;
            Options None
            AllowOverride None
            Order allow,deny
            allow from all
    &lt;/Directory&gt;
</code></pre>

<p></VirtualHost>
```</p>

<p>At this point, we just need to enable Apache at boot and replace the running
puppetmaster daemon:
<code>bash
chkconfig httpd on
service puppetmaster stop
service httpd start
</code></p>

<h3>Firewall setup</h3>

<p>Before rolling, we need to setup iptables and open the relevant port in order
for the master to be reachable:
<code>bash
vi /etc/sysconfig/iptables
</code>
<code>
...
-A INPUT -m state --state NEW -m tcp -p tcp --dport 8140 -j ACCEPT
...
</code>
<code>bash
service iptables restart
</code></p>

<h2>Testing the installation</h2>

<p>A quick test can be done on the master itself by running a one-shot agent, like
this:
<code>bash
puppet agent --test --debug
</code></p>

<p>If everything is working as expected, the last non-debug line should report a
notice that catalog run went fine:
<code>
Notice: Finished catalog run in 0.04 seconds
</code></p>

<p>Obviously, the master doesn't need to sign the certificate, since the agent is
picking the same certificate the master created on the first run. For the other
agents, we'll need to manually sign certificates when new CSRs arrive.</p>

<h2>To be continued...</h2>

<p>I wrap this post here, since it's already too long, but I'll continue in the
next one with an important task: putting Puppet's configuration under version
control and activating a (continuous) deployment pipeline in Jenkins for it.<br/>
I promise that will be more intersting than this post ;-)</p>
]]></content>
  </entry>
  
</feed>
