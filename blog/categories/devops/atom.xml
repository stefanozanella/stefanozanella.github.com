<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: devops | Stefano Zanella's Blog]]></title>
  <link href="http://blog.dontwakethecat.net/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://blog.dontwakethecat.net/"/>
  <updated>2013-02-13T23:21:39+01:00</updated>
  <id>http://blog.dontwakethecat.net/</id>
  <author>
    <name><![CDATA[Stefano Zanella]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Speaking in tongues with SSL]]></title>
    <link href="http://blog.dontwakethecat.net/blog/2013/01/22/speaking-in-tongues-with-ssl/"/>
    <updated>2013-01-22T16:56:00+01:00</updated>
    <id>http://blog.dontwakethecat.net/blog/2013/01/22/speaking-in-tongues-with-ssl</id>
    <content type="html"><![CDATA[<p>This was a nice one; let me explain.</p>

<p>I've setup a PotgreSQL host to hold all the various databases for the various
services deployed in the infrastructure. Since I know I'm not a security
expert, where I can I try to do the bare minumum needed and use SSL. This is
the case for PostgreSQL; not only, but I try hard to enforce two-way
certificate validation where possibile.</p>

<!-- More -->


<p>It turns out that despite the simplicity behind the concept of two-way
certificate validation, very few <em>"modern"</em> services support that in a
user-friendly way. I already had a chance to rant a bit on Twitter about the
problems Puppet is currently facing with SSL; this time I want to tell you this
story that involves the <a href="https://code.google.com/p/gerrit/">Gerrit Code Review</a>
application and the way I solved the problem, which in my opinion is quite
hacky (and will possibly break things in a near future).</p>

<p>First, a little overview of two-way SSL certificate validation. Basically, in
normal circumstances, during a SSL handshake, only the client verifies that the
certificate the server is providing is valid (checking against a list of known
and trusted Certificate Authorities); when performing two-way validation, this
process is true also for the server. That is, the server expects the client to
send a certificate and verifies that it can be trusted with the same mechanism.<br/>
This is useful when you're running your own PKI and can freely issue
certificates to all your hosts; it becomes a form of authentication similar to
that we all use when doing public key authentication in SSH (maybe even
stronger).<br/>
For this to work, obviously, there must be explicit configuration support on
the client service to point to certificate, private key and CA that will be
used when handshaking with the server. Also, note that you cannot simply
disable certificate validation, since this will only lower the barrier <strong>on one
side</strong> of the communication channel: the server will still require you (the
client) to provide a valid certificate (in most cases you can tell the server
to relax the constraint, but then this discussion would become a little
pointless).</p>

<p>Here is where problems begin: let's look specifically at how this can be
handled in Gerrit.<br/>
In particular, let's see how a typical database setup looks like in Gerrit:
<code>ini
[database]
  type = POSTGRESQL
  hostname = postgresql.derecom.it
  database = gerrit
  username = gerrit
</code>
This will tell JDBC to connect to <code>postgresql.derecom.it</code> and look for database
<code>gerrit</code>, authenticating with user <code>gerrit</code> (password is handled in another
file). See? No mention to <strong>SSL</strong>. Unofrtunately, JDBC doesn't automatically
recognizes that it needs to setup a SSL connection, and trying to boot the
gerrit server results in this kind of error on the PosgtreSQL host:
<code>
FATAL:  no pg_hba.conf entry for host "x.y.z.w", user "gerrit", database "gerrit", SSL off
</code>
(that's because I <strong>don't allow unencrypted connections to databases</strong>).</p>

<p>It seems that there's no hope to solve this. Luckily, though, Gerrit use JDBC
under the hood to manage the connection pool; looking through
<a href="http://jdbc.postgresql.org/documentation/80/connect.html">JDBC PosgtreSQL driver documentation</a>,
we can read that:</p>

<blockquote><p> In addition to the standard connection parameters the driver supports a
 number of additional properties which can be used to specify additional
 driver behavior specific to PostgreSQLâ„¢. These properties may be specified
 in either the connection URL or an additional Properties object parameter to
 DriverManager.getConnection. The following examples illustrate the use of
 both methods to establish a SSL connection.</p>

<p>String url = "jdbc:postgresql://localhost/test";<br/>
Properties props = new Properties();<br/>
props.setProperty("user","fred");<br/>
props.setProperty("password","secret");<br/>
props.setProperty("ssl","true");<br/>
Connection conn = DriverManager.getConnection(url, props);</p>

<p>String url =<br/>
"jdbc:postgresql://localhost/test?user=fred&amp;password=secret<strong>&amp;ssl=true</strong>";<br/>
Connection conn = DriverManager.getConnection(url);</p></blockquote>

<p>So, it seems that if we could pass a <code>ssl</code> parameter to the JDBC URL we could
enable SSL while connection to PostgreSQL. A first solution is to set the
connection type to <code>JDBC</code> instead of <code>POSTGRESQL</code> in Gerrit configuration. This
would allow you to directly specify the URL JDBC should connect to, parameters
included.<br/>
Since I didn't know if I would have had to specify also the user/pass in that
same URL, I wanted to try to stick to the <code>POSTGRESQL</code> type. Looking at
<a href="https://gerrit.googlesource.com/gerrit/+/7029fc15df86e6ef886d67a8117a39d21320fe60/gerrit-pgm/src/main/java/com/google/gerrit/pgm/util/DataSourceProvider.java">this class' source code</a>,
it turns out that Gerrit itself builds a JDBC URL, so using one of the other
connection types is just a tiny wrapper over the JDBC type. However, the URL is
built leaving out username and password, which are set separately when actually
instantiating the connection, and the last variable in the URL concatenation is
the database name. So, I modified the configuration by directly appending the
<code>ssl</code> param to the database name:
<code>ini
[database]
  type = POSTGRESQL
  hostname = postgresql.derecom.it
  database = gerrit?ssl=true
  username = gerrit
</code></p>

<p>You know what? That works like a charm :)<br/>
Obviously this is a bit hacky, and surely setting a JDBC is a more proper way
to handle this thing, however if it works...</p>

<p><strong>PS:</strong> I left out from the discussion a fundamental step, which is passing the
certificate, private key and CA to Gerrit to correctly handle the SSL
handshake. This involves passing two additional properties to Gerrit startup
command; I've already written down about it in
<a href="https://gist.github.com/4124338">this Gist</a>, so I won't repeat myself here.</p>

<h2>Conclusion</h2>

<p>So, having spent almost 2 hours fixing this issue and writing about it, what I
can hope for is that developers start to care a little more about SSL and the
various ways it can be used. This would surely help changing the impression
that SSL is a though beast, as also noticed by
<a href="https://twitter.com/_masterzen_">Brice Figureau</a> in
<a href="http://www.masterzen.fr/2010/11/14/puppet-ssl-explained/">this post about Puppet SSL PKI</a>, and making our
infrastructures more secure overall.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pre-flight debrief]]></title>
    <link href="http://blog.dontwakethecat.net/blog/2013/01/19/pre-flight-debrief/"/>
    <updated>2013-01-19T20:20:00+01:00</updated>
    <id>http://blog.dontwakethecat.net/blog/2013/01/19/pre-flight-debrief</id>
    <content type="html"><![CDATA[<p>I'm writing this post as a sort of disclamer for the posts that will follow in
the (hopefully near) future.</p>

<p>I became a fan of documentation near three years ago. Since then, I mantained
(and am still mantaining) a sort of private wiki where I try do document
whatever I do. In some cases, this practice saved my ass: since for the moment
I don't work in a team, I'm forced to continuously move between tasks that span
from the full Dev and Ops range. Sometimes quite some time can pass until I
need to return to a previous task to fix/improve things. This can be daunting,
since memory tends to be pretty unreliable in these cases; having a neat trace
of what I did helped me to quickly restore the archived knowledge.<br/>
Over time, documenting <strong>while</strong> doing has become almost a natural practice for
me, at least for what concerns operations tasks.</p>

<p>As stated above, till now I kept this documentation almost private, just
visible to interested friends that wanted to dig from time to time into what I
did; now I feel this practice has to change.<br/>
So, I decided to at least try to make my efforts public. I'm sure there won't
be crowds of developers or sysadmins waiting for my next post; I'm not doing it
for this reason. I'll just try to use the lever that is what in my opinion is
the biggest benfit of open source culture: it forces you to be better at what
you do.</p>

<p>So, this little detour over my recent history just to say one basic thing: I'm
gonna store here almost everything. So, expect to find obvious things as well
as not-so-obvious ones; actually, I suspect the former will overweight the latter
at least for the moment :)</p>

<p>Having clarified this basic concept, let's see what the sudden future reserves:
I'm gonna talk a lot in the following months about my efforts to automate the
infrastructure I'm actually managing. This effort started slightly more than a
year ago when I discovered the excellent <a href="http://continuousdelivery.com/">"Continuous Delivery" book</a>
by <a href="https://twitter.com/jezhumble">Jez Humble</a> and David Farley.
Meanwhile, I've done a lot to try to add some solid
ground on the infrastructure while maintaining the existent. I now reached a
point in which I can start to implement all those nice automation practices.<br/>
I'll try to convert documentation I've already written into something suitable
for the public audience; but, since I don't want to start yak shaving right
from the beginning, I'll try to stay pragmatic enough and start by writing
currently on-air tasks. For this reason, I apologize in advance if some pieces
will miss from what I'll write.</p>

<p>I force myself now to stop adding to this post; enough self-centered writing
for my tastes. Better to start writing something more practical; I'll start
with something very very basic and in very very little DevOps style: installing
a Puppet master node.</p>
]]></content>
  </entry>
  
</feed>
